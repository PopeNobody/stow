diff --git a/hide/Makefile b/hide/Makefile
new file mode 100644
index 0000000..0d1d7dc
--- /dev/null
+++ b/hide/Makefile
@@ -0,0 +1,12 @@
+all: test_some_shit
+
+test_some_shit:
+	perl -S vi_perl script.pl
+
+test_pkg_file:
+	vi_perl pkg-file /info/
+	@echo vi_perl bin/pkg-file /info/
+
+test_vi_perl:
+	@echo vi_perl bin/pkg-file /info/
+
diff --git a/hide/branches.sh b/hide/branches.sh
new file mode 100644
index 0000000..d0049f1
--- /dev/null
+++ b/hide/branches.sh
@@ -0,0 +1,14 @@
+#!/bin/bash
+
+set --  church nn-cripple nn-desktop nn-laptop nn-yy root_standard
+doit() {
+  m=master
+  while (($#)); do
+    echo
+    echo
+    echo echo vers: $m $1
+    echo git diff $m $1 -- .gitignore
+    shift
+  done
+};
+doit "$@"
diff --git a/hide/delta/church.master.delta b/hide/delta/church.master.delta
new file mode 100644
index 0000000..87b8e01
--- /dev/null
+++ b/hide/delta/church.master.delta
@@ -0,0 +1,29 @@
+diff --git a/doc/func_experiments.sh b/doc/func_experiments.sh
+deleted file mode 100644
+index cfece11..0000000
+--- a/doc/func_experiments.sh
++++ /dev/null
+@@ -1,16 +0,0 @@
+-x () 
+-{ 
+-  (($#)) || set -- church master nn-cripple nn-desktop nn-laptop;
+-    for i in "$@";
+-    do
+-      echo
+-      echo echo "doing: $i"
+-      echo
+-        echo git checkout master;
+-        echo git checkout $i;
+-        echo "echo $i | tee doc/ver";
+-        echo git commit doc/ver;
+-        echo git push;
+-        echo;
+-    done
+-}
+diff --git a/doc/ver b/doc/ver
+index 1f7391f..50bde64 100644
+--- a/doc/ver
++++ b/doc/ver
+@@ -1 +1 @@
+-master
++church
diff --git a/hide/delta/master.master.delta b/hide/delta/master.master.delta
new file mode 100644
index 0000000..e69de29
diff --git a/hide/delta/nn-cripple.master.delta b/hide/delta/nn-cripple.master.delta
new file mode 100644
index 0000000..b5d73d6
--- /dev/null
+++ b/hide/delta/nn-cripple.master.delta
@@ -0,0 +1,29 @@
+diff --git a/doc/func_experiments.sh b/doc/func_experiments.sh
+deleted file mode 100644
+index cfece11..0000000
+--- a/doc/func_experiments.sh
++++ /dev/null
+@@ -1,16 +0,0 @@
+-x () 
+-{ 
+-  (($#)) || set -- church master nn-cripple nn-desktop nn-laptop;
+-    for i in "$@";
+-    do
+-      echo
+-      echo echo "doing: $i"
+-      echo
+-        echo git checkout master;
+-        echo git checkout $i;
+-        echo "echo $i | tee doc/ver";
+-        echo git commit doc/ver;
+-        echo git push;
+-        echo;
+-    done
+-}
+diff --git a/doc/ver b/doc/ver
+index 1f7391f..6edc30a 100644
+--- a/doc/ver
++++ b/doc/ver
+@@ -1 +1 @@
+-master
++nn-cripple
diff --git a/hide/delta/nn-desktop.master.delta b/hide/delta/nn-desktop.master.delta
new file mode 100644
index 0000000..6877880
--- /dev/null
+++ b/hide/delta/nn-desktop.master.delta
@@ -0,0 +1,29 @@
+diff --git a/doc/func_experiments.sh b/doc/func_experiments.sh
+deleted file mode 100644
+index cfece11..0000000
+--- a/doc/func_experiments.sh
++++ /dev/null
+@@ -1,16 +0,0 @@
+-x () 
+-{ 
+-  (($#)) || set -- church master nn-cripple nn-desktop nn-laptop;
+-    for i in "$@";
+-    do
+-      echo
+-      echo echo "doing: $i"
+-      echo
+-        echo git checkout master;
+-        echo git checkout $i;
+-        echo "echo $i | tee doc/ver";
+-        echo git commit doc/ver;
+-        echo git push;
+-        echo;
+-    done
+-}
+diff --git a/doc/ver b/doc/ver
+index 1f7391f..75d6a5d 100644
+--- a/doc/ver
++++ b/doc/ver
+@@ -1 +1 @@
+-master
++nn-desktop
diff --git a/hide/delta/nn-laptop.master.delta b/hide/delta/nn-laptop.master.delta
new file mode 100644
index 0000000..deea52f
--- /dev/null
+++ b/hide/delta/nn-laptop.master.delta
@@ -0,0 +1,7 @@
+diff --git a/doc/ver b/doc/ver
+index 1f7391f..aade416 100644
+--- a/doc/ver
++++ b/doc/ver
+@@ -1 +1 @@
+-master
++nn-laptop
diff --git a/hide/delta/pkg-file b/hide/delta/pkg-file
new file mode 100755
index 0000000..fcb2bdd
--- /dev/null
+++ b/hide/delta/pkg-file
@@ -0,0 +1,134 @@
+#!/usr/bin/perl
+$|++;
+use autodie qw(:all);
+use strict;
+use warnings;
+use Data::Dumper;
+BEGIN {
+  sub qquote {
+    goto &Data::Dumper::qquote;
+  };
+};
+our($debug);
+
+sub help() {
+  print "usage: $0 [-zd] [-p pat | -f pat]\n";
+};
+sub version {
+  print "$0 version 0.1.0\n";
+};
+use Getopt::WonderBra;
+sub handle_arg($);
+sub mainloop();
+
+BEGIN {
+  print STDOUT "STDOUT\n";
+  print STDERR "STDERR\n";
+};
+BEGIN {
+  $\="\n"; $,=" "; $"=" ";
+  $Data::Dumper::Useqq=1;
+  $Data::Dumper::Deparse=1;
+  $Data::Dumper::Sortkeys=1;
+};
+use vars qw( %args );
+$_=undef for @args{ qw( pat type ) };
+$_=0     for @args{ qw( zipped debug dump ) };
+
+@ARGV=getopt( 'wpflzdD', @ARGV );
+handle_arg(shift(@ARGV)) while(@ARGV);
+die "no pats, and did not die!" unless defined($args{pat});
+for($args{type}) {
+  $_="file" unless defined;
+};
+mainloop();
+exit(0);
+
+use vars qw( $qr );
+
+sub mainloop()
+{
+  my $fn="/var/cache/apt/apt-file-search-slash";
+  if($args{zipped}) {
+    $fn = "zcat $fn.gz|";
+  } else {
+    $fn = "<$fn";
+  };
+  $qr=$args{pat};
+  $qr=qr{$qr};
+  #  my $proc;
+#      if( $args{type} eq "package" ) {
+#        $proc=sub(@) {
+#          return grep {
+#            my ($pkg,$file) = m{^(\S+):\s+(\S.*\S)};
+#            $pkg =~/$qr/;
+#          } @_;
+#        };
+#      } elsif ( $args{type} eq "file" ) {
+#        $proc=sub(@) {
+#          return grep {
+#            my ($pkg,$file) = m{^(\S+):\s+(\S.*\S)};
+#            $file =~/$qr/;
+#          } @_;
+#        };
+#      } else {
+#        $proc=sub(@) {
+#          return grep /$qr/, @_;
+#        };
+#      };
+
+  print STDERR "fn=( $fn )\n";
+  open(STDIN,"$fn");
+  while(<$STDIN>){
+    chomp;
+    print;
+  };
+  close(STDIN) or die "close:$fn:$!";
+  open(STDIN,"</dev/null");
+};
+
+sub set_type($) {
+  local *_=\$args{type};
+  die "only one type alowed" if defined;
+  $_=shift;
+};
+sub handle_arg($)
+{
+  print STDERR "handle_arg(@_,@ARGV)\n";
+  my $hands={
+    '-p' => sub{ set_type('package'); },
+    '-f' => sub{ set_type('file'); },
+    '-l' => sub{ set_type('line'); },
+    '-w' => sub{ $_=!$_ for $args{whole}; },
+    '-z' => sub{ $_=!$_ for $args{zipped}; },
+    '-d' => sub{ $_++ for $args{debug}; },
+    '-D' => sub{ $_=!$_ for $args{dump}; },
+    '--' => sub{
+      die "I need patterns!" unless @ARGV;
+      $args{pat}=shift @ARGV;
+      die "Too many args!" if @ARGV;
+    },
+  };
+  for(@_) {
+    my $hand=$hands->{$_};
+    die "I do not grok '$_'" unless defined $hand;
+    $hand->($_,@ARGV);
+  };
+};
+#    sub maybe_print
+#    {
+#      if( grep { $line =~ $_ } @lpats ) {
+#        1;
+#      } elsif( grep { $pkg =~ $_ } @ppats ) {
+#        $done{$pkg}=1;
+#      } elsif ( grep { $path =~ $_ } @fpats ) {
+#        1;
+#      } else {
+#        return 0;
+#      };
+#      print "$pkg $path";
+#      return 1;
+#    };
+#    my $stime=time;
+#    my $match=0;
+#    close(STDIN);
diff --git a/hide/delta/pkg-file-ver1 b/hide/delta/pkg-file-ver1
new file mode 100755
index 0000000..37da532
--- /dev/null
+++ b/hide/delta/pkg-file-ver1
@@ -0,0 +1,133 @@
+#!/usr/bin/perl
+$|++;
+use autodie qw(:all);
+use strict;
+use warnings;
+use Data::Dumper;
+BEGIN {
+  sub qquote {
+    goto &Data::Dumper::qquote;
+  };
+};
+our($debug);
+
+sub help() {
+  print "usage: $0 [-zd] [-p pat | -f pat]\n";
+};
+sub version {
+  print "$0 version 0.1.0\n";
+};
+use Getopt::WonderBra;
+sub handle_arg($);
+sub mainloop();
+
+BEGIN {
+  print STDOUT "STDOUT\n";
+  print STDERR "STDERR\n";
+};
+BEGIN {
+  $\="\n"; $,=" "; $"=" ";
+  $Data::Dumper::Useqq=1;
+  $Data::Dumper::Deparse=1;
+  $Data::Dumper::Sortkeys=1;
+};
+use vars qw( %args );
+$_=undef for @args{ qw( pat type ) };
+$_=0     for @args{ qw( zipped debug dump ) };
+
+@ARGV=getopt( 'wpflzdD', @ARGV );
+handle_arg(shift(@ARGV)) while(@ARGV);
+die "no pats, and did not die!" unless defined($args{pat});
+for($args{type}) {
+  $_="file" unless defined;
+};
+mainloop();
+exit(0);
+
+use vars qw( $qr );
+
+sub mainloop()
+{
+  my $fn="/var/cache/apt/apt-file-search-slash";
+  if($args{zipped}) {
+    $fn = "zcat $fn.gz|";
+  } else {
+    $fn = "<$fn";
+  };
+  $qr=$args{pat};
+  $qr=qr{$qr};
+  #  my $proc;
+#      if( $args{type} eq "package" ) {
+#        $proc=sub(@) {
+#          return grep {
+#            my ($pkg,$file) = m{^(\S+):\s+(\S.*\S)};
+#            $pkg =~/$qr/;
+#          } @_;
+#        };
+#      } elsif ( $args{type} eq "file" ) {
+#        $proc=sub(@) {
+#          return grep {
+#            my ($pkg,$file) = m{^(\S+):\s+(\S.*\S)};
+#            $file =~/$qr/;
+#          } @_;
+#        };
+#      } else {
+#        $proc=sub(@) {
+#          return grep /$qr/, @_;
+#        };
+#      };
+
+  open(STDIN,"$fn");
+  while($proc->(<STDIN>)){
+    chomp;
+    print;
+  };
+  close(STDIN) or die "close:$fn:$!";
+  open(STDIN,"</dev/null");
+};
+
+sub set_type($) {
+  local *_=\$args{type};
+  die "only one type alowed" if defined;
+  $_=shift;
+};
+sub handle_arg($)
+{
+  print STDERR "handle_arg(@_,@ARGV)\n";
+  my $hands={
+    '-p' => sub{ set_type('package'); },
+    '-f' => sub{ set_type('file'); },
+    '-l' => sub{ set_type('line'); },
+    '-w' => sub{ $_=!$_ for $args{whole}; },
+    '-z' => sub{ $_=!$_ for $args{zipped}; },
+    '-d' => sub{ $_++ for $args{debug}; },
+    '-D' => sub{ $_=!$_ for $args{dump}; },
+    '--' => sub{
+      die "I need patterns!" unless @ARGV;
+      $args{pat}=shift @ARGV;
+      die "Too many args!" if @ARGV;
+    },
+  };
+  for(@_) {
+    my $hand=$hands->{$_};
+    die "I do not grok '$_'" unless defined $hand;
+    $hand->($_,@ARGV);
+  };
+};
+#    sub maybe_print
+#    {
+#      if( grep { $line =~ $_ } @lpats ) {
+#        1;
+#      } elsif( grep { $pkg =~ $_ } @ppats ) {
+#        $done{$pkg}=1;
+#      } elsif ( grep { $path =~ $_ } @fpats ) {
+#        1;
+#      } else {
+#        return 0;
+#      };
+#      print "$pkg $path";
+#      return 1;
+#    };
+#    my $stime=time;
+#    my $match=0;
+#    close(STDIN);
diff --git a/hide/delta/pkg-file-ver2 b/hide/delta/pkg-file-ver2
new file mode 100755
index 0000000..7e870d4
--- /dev/null
+++ b/hide/delta/pkg-file-ver2
@@ -0,0 +1,123 @@
+#!/usr/bin/perl
+$|++;
+use autodie qw(:all);
+use strict;
+use warnings;
+use Data::Dumper;
+BEGIN {
+  sub qquote {
+    goto &Data::Dumper::qquote;
+  };
+};
+our($debug);
+
+sub help() {
+  print "usage: $0 [-zd] [-p pat | -f pat]\n";
+};
+sub version {
+  print "$0 version 0.1.0\n";
+};
+use Getopt::WonderBra;
+sub handle_arg($);
+sub mainloop();
+
+BEGIN {
+  print STDOUT "STDOUT\n";
+  print STDERR "STDERR\n";
+};
+BEGIN {
+  $\="\n"; $,=" "; $"=" ";
+  $Data::Dumper::Useqq=1;
+  $Data::Dumper::Deparse=1;
+  $Data::Dumper::Sortkeys=1;
+};
+use vars qw( %args );
+$_=undef for @args{ qw( pat type ) };
+$_=0     for @args{ qw( zipped debug dump ) };
+
+@ARGV=getopt( 'wpflzdD', @ARGV );
+handle_arg(shift(@ARGV)) while(@ARGV);
+die "no pats, and did not die!" unless defined($args{pat});
+for($args{type}) {
+  $_="file" unless defined;
+};
+mainloop();
+exit(0);
+
+
+sub mainloop()
+{
+  my $fn="/var/cache/apt/apt-file-search-slash";
+  if($args{zipped}) {
+    $fn = "zcat $fn.gz|";
+  } else {
+    $fn = "<$fn";
+  };
+  my $qr=$args{pat};
+  $qr=qr{$qr};
+  my $proc;
+  if( $args{type} eq "package" ) {
+    proc=sub(@) {
+      return grep {
+        my ($pkg,$file) = m{^(\S+):\s+(\S.*\S)};
+        $pkg =~/$qr/;
+      } @_;
+    };
+  } elsif ( $args{type} eq "file" ) {
+    print if $file =~ /$qr/;
+  } else {
+    print if $_ =~ /$qr/;
+  };
+  open(STDIN,"$fn");
+  while(<STDIN>){
+    chomp;
+  };
+  close(STDIN) or die "close:$fn:$!";
+  open(STDIN,"</dev/null");
+};
+
+sub set_type($) {
+  local *_=\$args{type};
+  die "only one type alowed" if defined;
+  $_=shift;
+};
+sub handle_arg($)
+{
+  print STDERR "handle_arg(@_,@ARGV)\n";
+  my $hands={
+    '-p' => sub{ set_type('package'); },
+    '-f' => sub{ set_type('file'); },
+    '-l' => sub{ set_type('line'); },
+    '-w' => sub{ $_=!$_ for $args{whole}; },
+    '-z' => sub{ $_=!$_ for $args{zipped}; },
+    '-d' => sub{ $_++ for $args{debug}; },
+    '-D' => sub{ $_=!$_ for $args{dump}; },
+    '--' => sub{
+      die "I need patterns!" unless @ARGV;
+      $args{pat}=shift @ARGV;
+      die "Too many args!" if @ARGV;
+    },
+  };
+  for(@_) {
+    my $hand=$hands->{$_};
+    die "I do not grok '$_'" unless defined $hand;
+    $hand->($_,@ARGV);
+  };
+};
+#    sub maybe_print
+#    {
+#      if( grep { $line =~ $_ } @lpats ) {
+#        1;
+#      } elsif( grep { $pkg =~ $_ } @ppats ) {
+#        $done{$pkg}=1;
+#      } elsif ( grep { $path =~ $_ } @fpats ) {
+#        1;
+#      } else {
+#        return 0;
+#      };
+#      print "$pkg $path";
+#      return 1;
+#    };
+#    my $stime=time;
+#    my $match=0;
+#    close(STDIN);
diff --git a/hide/pkg-file b/hide/pkg-file
new file mode 100755
index 0000000..37da532
--- /dev/null
+++ b/hide/pkg-file
@@ -0,0 +1,133 @@
+#!/usr/bin/perl
+$|++;
+use autodie qw(:all);
+use strict;
+use warnings;
+use Data::Dumper;
+BEGIN {
+  sub qquote {
+    goto &Data::Dumper::qquote;
+  };
+};
+our($debug);
+
+sub help() {
+  print "usage: $0 [-zd] [-p pat | -f pat]\n";
+};
+sub version {
+  print "$0 version 0.1.0\n";
+};
+use Getopt::WonderBra;
+sub handle_arg($);
+sub mainloop();
+
+BEGIN {
+  print STDOUT "STDOUT\n";
+  print STDERR "STDERR\n";
+};
+BEGIN {
+  $\="\n"; $,=" "; $"=" ";
+  $Data::Dumper::Useqq=1;
+  $Data::Dumper::Deparse=1;
+  $Data::Dumper::Sortkeys=1;
+};
+use vars qw( %args );
+$_=undef for @args{ qw( pat type ) };
+$_=0     for @args{ qw( zipped debug dump ) };
+
+@ARGV=getopt( 'wpflzdD', @ARGV );
+handle_arg(shift(@ARGV)) while(@ARGV);
+die "no pats, and did not die!" unless defined($args{pat});
+for($args{type}) {
+  $_="file" unless defined;
+};
+mainloop();
+exit(0);
+
+use vars qw( $qr );
+
+sub mainloop()
+{
+  my $fn="/var/cache/apt/apt-file-search-slash";
+  if($args{zipped}) {
+    $fn = "zcat $fn.gz|";
+  } else {
+    $fn = "<$fn";
+  };
+  $qr=$args{pat};
+  $qr=qr{$qr};
+  #  my $proc;
+#      if( $args{type} eq "package" ) {
+#        $proc=sub(@) {
+#          return grep {
+#            my ($pkg,$file) = m{^(\S+):\s+(\S.*\S)};
+#            $pkg =~/$qr/;
+#          } @_;
+#        };
+#      } elsif ( $args{type} eq "file" ) {
+#        $proc=sub(@) {
+#          return grep {
+#            my ($pkg,$file) = m{^(\S+):\s+(\S.*\S)};
+#            $file =~/$qr/;
+#          } @_;
+#        };
+#      } else {
+#        $proc=sub(@) {
+#          return grep /$qr/, @_;
+#        };
+#      };
+
+  open(STDIN,"$fn");
+  while($proc->(<STDIN>)){
+    chomp;
+    print;
+  };
+  close(STDIN) or die "close:$fn:$!";
+  open(STDIN,"</dev/null");
+};
+
+sub set_type($) {
+  local *_=\$args{type};
+  die "only one type alowed" if defined;
+  $_=shift;
+};
+sub handle_arg($)
+{
+  print STDERR "handle_arg(@_,@ARGV)\n";
+  my $hands={
+    '-p' => sub{ set_type('package'); },
+    '-f' => sub{ set_type('file'); },
+    '-l' => sub{ set_type('line'); },
+    '-w' => sub{ $_=!$_ for $args{whole}; },
+    '-z' => sub{ $_=!$_ for $args{zipped}; },
+    '-d' => sub{ $_++ for $args{debug}; },
+    '-D' => sub{ $_=!$_ for $args{dump}; },
+    '--' => sub{
+      die "I need patterns!" unless @ARGV;
+      $args{pat}=shift @ARGV;
+      die "Too many args!" if @ARGV;
+    },
+  };
+  for(@_) {
+    my $hand=$hands->{$_};
+    die "I do not grok '$_'" unless defined $hand;
+    $hand->($_,@ARGV);
+  };
+};
+#    sub maybe_print
+#    {
+#      if( grep { $line =~ $_ } @lpats ) {
+#        1;
+#      } elsif( grep { $pkg =~ $_ } @ppats ) {
+#        $done{$pkg}=1;
+#      } elsif ( grep { $path =~ $_ } @fpats ) {
+#        1;
+#      } else {
+#        return 0;
+#      };
+#      print "$pkg $path";
+#      return 1;
+#    };
+#    my $stime=time;
+#    my $match=0;
+#    close(STDIN);
diff --git a/hide/vi_perl b/hide/vi_perl
new file mode 100755
index 0000000..8269c71
--- /dev/null
+++ b/hide/vi_perl
@@ -0,0 +1,201 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+use autodie qw(:all);
+sub find_script($);
+use autodie qw(fork);
+use Cwd qw(realpath getcwd);
+use vars qw(@path  );
+use vars qw(@build @exist);
+
+use IO::Pipe;
+
+use File::stat;
+BEGIN {
+  use vars qw( %proc  @proc  $proc );
+  use vars qw( @script );
+
+  $|++; $\="\n";
+
+  sub main(@);
+  sub hr;
+  sub main(@);
+  sub splitpath($);
+  sub run_perl($$@);
+  sub watch_perl($$);
+  sub splitpath($);
+  sub find_script($);
+  sub hr;
+}
+
+
+#print STDERR join(':',__FILE__,__LINE__,"main(@ARGV)"),"\n";
+die "usage: $0 [script and args ...] ...\n..." unless @ARGV;
+my $res=main(@ARGV);
+#print STDERR join(':',__FILE__,__LINE__,"main(@ARGV) => $res"),"\n";
+exit($res);
+
+die "exit:$!";
+use Data::Dumper;
+BEGIN {
+  $Data::Dumper::Deparse=1;
+  $Data::Dumper::Terse=1;
+  $Data::Dumper::Useqq=1;
+};
+{
+  sub main(@)
+  {
+    local (@_) = splice(@_);
+    open(OLDERR,">&STDERR");
+    open(STDIN,"</dev/null");
+    print OLDERR join(':',__FILE__,__LINE__,"enter main(@_)\n");
+
+    for(@proc) {
+      print Dumper($_);
+      exit(0);
+    };
+
+    print OLDERR join(':',__FILE__,__LINE__,"_exit main(@_)\n");
+    close(STDIN);
+    close(STDERR);
+    close(STDOUT);
+    close(OLDERR);
+    return 0;
+  };
+
+#        my $hide=q[
+#        my ($init_pid,$pid)=$$;
+#        my (@pipe);
+#        @_ = map { +{ pipe=>new IO::Pipe, proc=>$_, } } @_;
+#        if( ($pid=fork)==0 ) {
+#          print join(':',__FILE__,__LINE__,"part1()");
+#        } elsif( ($pid=fork)==0 ) {
+#          print join(':',__FILE__,__LINE__,"part2()");
+#        } else {
+#          print join(':',__FILE__,__LINE__,"part3()");
+#        };
+#        ];
+
+  sub run_perl($$@)
+  {
+    print OLDERR join(':',__FILE__,__LINE__,"$$:run_perl(@_)");
+    my (@script) = find_script(shift(@_));
+    @_ = ( "perl", shift(@script), @_ );
+    my ($out,$err,@args) = @_;
+    open(STDOUT,">&".fileno($out->writer)) or die;
+    open(STDERR,">&".fileno($err->writer)) or die;
+    close($out);
+    close($err);
+    exec(@_);
+    die "failed!";
+  };
+  sub watch_perl($$)
+  {
+    print OLDERR join(':',__FILE__,__LINE__,"$$:watch_perl(@_)");
+    my ($out,$err) = @_;
+    use IO::Select;
+    my $sel = new IO::Select;
+    my $out_buf="";
+    my $err_buf="";
+    $sel->add( [ $out->reader(), \$out_buf, 0 ] );
+    $sel->add( [ $err->reader(), \$err_buf, 1 ] );
+    while($sel->handles)
+    {
+      my @can=$sel->can_read;
+      for(@can)
+      {
+        my ($pipe,$ref,$id);
+        ( $pipe, $ref, $id ) = @$_;
+        local (*_)=$ref;
+        my $res=sysread($pipe,$_,1,length);
+        if(!defined($res)) {
+          die "sysread:$!";
+        } elsif ( !$res ) {
+          $sel->remove($pipe);
+          close($pipe) or die "close:$!";
+          $_="$_\n" if length($$ref);
+        };
+        next unless chomp;
+        if($id && s{ at (\S+) line (\d+)\.*}{})
+        {
+          my ($file,$line) = ($1,$2);
+          s{^\t(.*)called\s*$}{called from $1};
+          print STDERR "$file:$line: msg $_";
+        } else {
+          print STDOUT "$_";
+        };
+        $_="";
+      };
+    };
+  };
+  sub splitpath($)
+  {
+    return map { split qr{:+} } @_;
+  };
+  sub find_script($)
+  {
+    my (@path,$script);
+    if( @_ && defined($_[0]) ) {
+      $script=shift;
+    } else {
+      die "usage: find_script(basename)\n\n";
+    };
+
+    if( substr($script,0,1) eq '/' ) {
+      push(@path, '');
+    } else {
+      push(@path, splitpath($ENV{PATH}));
+    };
+    $_=join('/',$_,$script) for @path;
+    return grep { lstat($_) || stat($_) } @path;
+  };
+  sub hr {
+    print "\n".join('', map { ' <-> ' } 1 .. 20)."\n\n";
+  };
+  use vars qw( $run_perl $watch_perl ); 
+  sub make_proc(&)
+  {
+    our (%self,$self);
+    our ($proc)=shift;
+    $self=\$self;
+    $self{sub}=$proc;
+    $self{pid}=-1;
+    $self{fds}[0]="</dev/null";
+    $self{fds}[1]=new IO::Pipe;
+    $self{fds}[2]=new IO::Pipe;
+    return $self;
+  };
+  sub make_procs()
+  {
+    local (@_);
+    print STDERR "make_procs(@_)";
+    $run_perl=sub { &main::run_perl(@_); };
+    $watch_perl=sub { &main::watch_perl(@_); };
+    print STDERR Dumper(
+      {
+        run_perl => \&run_perl,
+        watch_perl => \&watch_perl,
+      }
+    );
+
+
+    #push(@_, make_proc({ &main::run_perl }));
+    #push(@_, make_proc({ &main::watch_perl }));
+    return () unless defined wantarray;
+    return \@_ unless wantarray;
+    print STDERR "make_procs(@_) returning";
+    return @_;
+  };
+};
+BEGIN {
+  @proc=make_procs();
+
+#      sub doit() {
+#        print Dumper( [ \$proc, \@proc, \%proc ] );
+#        print "\n";
+#        print Dumper( [ \$proc, \@proc, \%proc ] );
+#        return 1;
+#      };
+#      my $x=doit();
+};
