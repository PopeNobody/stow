#!/usr/bin/perl
$|++;
use autodie qw(:all);
use strict;
use warnings;
use Data::Dumper;
use Getopt::WonderBra;
BEGIN {
  $|++;
  $\="\n"; $,=" "; $"=" ";
  $Data::Dumper::Useqq=1;
  $Data::Dumper::Deparse=1;
  $Data::Dumper::Sortkeys=1;
};

our($debug);

sub help() {
  print "usage: $0 [-zd] [-p pat | -f pat]\n";
};
sub version {
  print "$0 version 0.1.0\n";
};
sub handle_arg($);
sub mainloop();


use vars qw( %args );

$_=undef for @args{ qw( pat type ) };
$_=0     for @args{ qw( zipped debug dump whole ) };

@ARGV=getopt( 'wpflzdD', @ARGV );
handle_arg(shift(@ARGV)) while(@ARGV);
die "no pats, and did not die!" unless defined($args{pat});
$args{type}='file' unless defined($args{type});
mainloop();
exit(0);
{
  my $qr;
  sub file_match {
    while(<STDIN>){
      chomp;
      my ($pkg,$file) = m{^(\S+):\s+(\S.*\S)};
      print if $file=~m{$qr};
    };
  };
  sub pack_match {
    while(<STDIN>){
      chomp;
      my ($pkg,$file) = m{^(\S+):\s+(\S.*\S)};
      print if $pkg=~m{$qr};
    };
  };
  sub line_match {
    while(<STDIN>){
      chomp;
      print if m{$qr};
    };
  };
  sub mainloop()
  {
    my $fn="/var/cache/apt/apt-file-search-slash";
    if($args{zipped}) {
      $fn = "zcat $fn.gz|";
    } else {
      $fn = "<$fn";
    };
    $qr=$args{pat};
    if($args{whole})
    {
      $qr=join('','^',$qr,'$');
    };
    $qr=qr{$qr};
    open(STDIN,"$fn");

    if( $args{type} eq 'file' ) {
      file_match;
    } elsif ( $args{type} eq 'package' ) {
      pack_match;
    } elsif ( $args{type} eq 'line' ) {
      line_match;
    } else {
      die "idk how to handle $args{type}";
    };

    close(STDIN);
    die "$@" if "$@";
    open(STDIN,"</dev/null");
  };

  sub set_type($) {
    local *_=\$args{type};
    die "only one type alowed" if defined;
    $_=shift;
  };
  sub handle_arg($)
  {
    my $hands={
      '-p' => sub{ set_type('package'); },
      '-f' => sub{ set_type('file'); },
      '-l' => sub{ set_type('line'); },
      '-w' => sub{ $_=!$_ for $args{whole}; },
      '-z' => sub{ $_=!$_ for $args{zipped}; },
      '-d' => sub{ $_++ for $args{debug}; },
      '-D' => sub{ $_=!$_ for $args{dump}; },
      '--' => sub{
        die "I need patterns!" unless @ARGV;
        $args{pat}=shift @ARGV;
        die "Too many args!" if @ARGV;
      },
    };
    for(@_) {
      my $hand=$hands->{$_};
      die "I do not grok '$_'" unless defined $hand;
      $hand->($_,@ARGV);
    };
  };
};
