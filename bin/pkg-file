#!/usr/bin/perl
$|++;

use strict;
use warnings;
BEGIN {
  use FindBin qw($Bin);
  use lib "$Bin/../lib/perl";
  $|++;
  $\="\n"; $,=" "; $"=" ";
};
use autodie qw(:all);
use Getopt::WonderBra;
use File::Basename;
use File::Copy;
use Data::Dump;

use vars qw( %data );
$data{fn}="/var/cache/apt/apt-file-search-slash";

sub cat(@);
sub help {
  print "error: @_" if @_;
  print "$0 ( -u | -p | -f | -l | -d | -D ) [ packages ]";
  my $text=qq{
  usage:

  -u update cache file, using apt-file.  no other args
  -p match our regex against the pkg side
  -f match our regex agaisnt the file side
  -l match our regex against the line side
  -d use the pwd, anchored on the left, as your pattern
  -D do the same, but don't anchor the pattern.
  -r add the following token to the regex list
  };
  for(split /\n/, $text){
    s{^\s*}{};
    print "    $_";
  };
  exit(1) if @_;
};
sub set_type() {
  die "type already specified, got '$_'" if defined($data{type});
  ddx([ \$_, \@_ ]);
  $data{type}=$_;
};

sub version {
  print "$0 version 0.2.0\n";
};
sub main();
exit(main());
die "wtf?";

<<<<<<< HEAD
our(%type);
BEGIN {
  $type{file}='^\S+:\s+(.*)';
  $type{pack}='^(\S+):\s+(.*)';
  $type{line}='^(.*)$';
};
sub get_pre($) {
  local($_)=shift;
  die "no type" unless defined;
  $_=$type{$_};
  die "no qr" unless defined;
  return qr{$_};
};

sub cat(@){
  return map { cat($_) } @_ unless 1==@_;
  open(my $fh,"<".shift);
  @_=<$fh>;
  close($fh);
  return @_;
};
sub loop() {
  my $qr=$data{qr};
  die "no pattern" unless defined $qr;
  #ddx($qr);
  $qr = qr{$qr} if defined $qr;
  #ddx($qr);
  die "no qr in:\n", pp(\%data) unless defined $qr;
  my $pre = get_pre($data{type});
  open(STDIN,"<$data{fn}");
  #ddx({pre=>$pre, qr=>$qr});
  while(<STDIN>){
    chomp;
    @_ = m{$pre};
    my ($match)=0;
    for(shift){
      $match = 1 if /$qr/;
    };
    print if $match;
  };
  close(STDIN);
  open(STDIN,"</dev/null");
  return 0;
};
our(%opt);
sub opt($$$){
  my (%tmp);
  $tmp{type}=shift;
  $tmp{dir}=shift;
  $tmp{update}=shift;
=======


sub loop() {
  use Data::Dump;
  #  ddx([ \@_, \%data ]);
  my $qr=$data{qr};
  die "no qr in:\n", pp(\%data) unless defined $qr;
  open(STDIN,"<$data{fn}");
  my $pre;
  if( $data{type} eq 'file' ) {
    $pre=qr{^\S+:\s+(.*)};
  } elsif ( $data{type} eq 'package' ) {
    $pre=qr{^(\S+):\s+(.*)};
  };
  if(defined($pre)){
    if(open(STDOUT,"|-")){
      print "TRUE";
    } else {
      print "FALSE";
    }
  }

  while(<STDIN>){
    next unless m{:.*$qr};
    chomp;
    my ($pkg,$file) = m{^(\S+):\s+(\S.*\S)};
    print if $file=~m{$qr};
  };
  close(STDIN);
  die "$@" if "$@";
  open(STDIN,"</dev/null");
  return 0;
};
our(%opt);
sub opt($$){
  my (%tmp);
  $tmp{type}=shift;
  $tmp{dir}=shift;
>>>>>>> 40963ce (fixed up pkg-file and several more.  renamed scripts with _ to -)
  $tmp{start}=0;
  return \%tmp;  
};
BEGIN {
<<<<<<< HEAD
  $opt{-d}=opt( 'file', 1, 0);
  $opt{-d}{start}=1;
  $opt{-D}=opt( 'file', 1, 0);
  $opt{-f}=opt( 'file', 0, 0);
  $opt{-l}=opt( 'line', 0, 0);
  $opt{-p}=opt( 'pack', 0, 0);
  $opt{-u}=opt( undef, 0, 1 );
}
sub debug {
};
sub main()
{
  local $_;
  local(*_)=\@ARGV;
  help("no args provided") unless @_;
  my $sel;
  #my $ddx=[ \$_, \$sel, \%data, \%opt, \@_ ];
  my $update = 0;
=======
  #ddx(\%opt);
  $opt{-d}=opt( 'file', 1);
  #  ddx(\%opt);
  $opt{-d}{start}=1;
  $opt{-D}=opt( 'file', 1);
  $opt{-f}=opt( 'file', 0);
  $opt{-l}=opt( 'line', 0);
  $opt{-p}=opt( 'package', 0);
}
ddx(\%opt);
sub main(@)
{
  local $_;
  our(@_);
  my $sel;
  my $ddx=[ \$_, \$sel, \%data, \%opt, \@_ ];
>>>>>>> 40963ce (fixed up pkg-file and several more.  renamed scripts with _ to -)

  $data{orig}=[@_];
  @_=getopt('upfldD',@_);
  $data{prod}=[@_];
  if(@_){
<<<<<<< HEAD
    while(($_=shift)ne'--')
=======
    while(($_=shift(@_))ne'--')
>>>>>>> 40963ce (fixed up pkg-file and several more.  renamed scripts with _ to -)
    {
      die "more than opt flag!" if defined $sel;
      $sel=$opt{$_};
    }
  }
  $sel = $opt{-l} unless $sel;
<<<<<<< HEAD
  if($sel->{update}){
    print STDERR "running update";
    update();
  } else {
    #die "sel is not a HASH ",pp($ddx) unless ref($sel) eq 'HASH';
    for(keys %{$sel}){
      $data{$_}=$sel->{$_};
    };
=======
  die "sel is not a ref: ",pp($ddx) unless ref($sel) eq 'HASH';
  for(keys %{$sel}){
    $data{$_}=$sel->{$_};
  };
>>>>>>> 40963ce (fixed up pkg-file and several more.  renamed scripts with _ to -)

    die "need exactly one pattern" unless @_==1;
    die "qr already defined" if defined $data{qr};
    $data{qr}=shift;
    die "missing type: ", pp(\%data) unless defined($data{type});

<<<<<<< HEAD
    #ddx( [ { "pos" => "about to call" }, $ddx  ] );
    #die "need pattern" unless defined($data{qr});
    print STDERR "running loop";
    return loop();
  }
};

sub update() {
  open(STDOUT,">$data{fn}.new");
  open(STDIN,"apt-file search /|");
  local($\)="";
  while(<STDIN>){
    print;
  };
  if( -e "$data{fn}" ) {
    rename("$data{fn}",     "$data{fn}.old");
  }
  rename("$data{fn}.new", "$data{fn}"    );
  return 0;
};
=======
  if(@_) {
    die if defined $data{qr};
    $data{qr}=shift;
  } else {
    die "no qr: ", ppx(\%data) unless defined($data{qr});
  };
  die "missing type: ", pp(\%data) unless defined($data{type});

  #ddx( [ { "pos" => "about to call" }, $ddx  ] );
  die "need pattern" unless defined($data{qr});
  return loop();
};

sub update() {
  if(grep { defined } map { $data{$_} } qw(type whole qr ))
  {
    die "update should be used alone."
  };
  open(STDOUT,">$data{fn}.new");
  open(STDIN,"apt-file search /|ts");
  local($\)="";
  print "\n";
  rename("$data{fn}",     "$data{fn}.old");
  rename("$data{fn}.new", "$data{fn}"    );
  return 0;
};
__DATA__
usage: - [-ud] [-p qr | -f qr]
-u update:   our cache file, using apt-file
-p package:  match our regex against the pkg side
-f file:     match our regex agaisnt the file side
-l line:     match our regex against the line side
-d           use the pwd, anchored on the left, as your pattern
-D           do the same, but don't anchor the pattern.
-r           add the following token to the regex list
>>>>>>> 40963ce (fixed up pkg-file and several more.  renamed scripts with _ to -)
