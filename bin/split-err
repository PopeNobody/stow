#!/usr/bin/perl
# vim: ts=2 sw=2 ft=perl
eval 'exec perl -x -wS $0 ${1+"$@"}'
$|++;
use autodie;
use common::sense;
use Time::HiRes qw( time alarm );
use Nobody::Util;
use AnyEvent;
use AE;
use EV;
open(STDLOG,">&STDERR");

sub forkoff( ) {
  my ($i,$o,$e);

  my ($p)=1 || fork;
  my ($t);
  pipe(R__IN, W__IN);
  pipe(R__OUT,W__OUT);
  pipe(R__ERR,W__ERR);
  if($p) {
    return (
      [ *STDIN, $i->writer ],
      [ $o->reader, *STDOUT ],
      [ $e->reader, *STDOUT ],
    );
  } else {
    open(STDIN,"<&".fileno($i->reader));
    open(STDOUT,">&".fileno($o->writer));
    open(STDERR,">&".fileno($e->writer));
    push(@_, qw(cat));
    exec(@_);
    die "NONE SHALL PASS" };
};
#  blessed        refaddr            reftype     weaken
#  unweaken       isweak             dualvar     isdual
#  isvstring      looks_like_number  openhandle  readonly
#  set_prototype  tainted                        
use Scalar::Util qw( 
blessed refaddr reftype  
blessed  openhandle
);
sub whatis($);
sub whatis($) {
  local($_)=shift;
  my %x;
  $x{defined}=[defined($_)];
  $x{blessed}=[blessed($_)];
  $x{ref}=[ref($)];
    $x{value}="$_";
    ddx(whatis($_));
  };
  my $ind;
  sub dumpref($);
  sub str($) {
    return "$_[0]";
  };
  sub main {
    my $ppid=$$;
    our(@io);
    @io=forkoff();
    ddx(\@io);
    use IO::Select;
    my $sel = new IO::Select;
    ddx($_) for @io;
    $sel->add($_) for @io;
    warn "$@" if "$@";
    while($sel->handles){
      my ($i,$o,@r) = @$_;

      my $buf="";
      my $nr=sysread($_->[0],$buf,10);
      if($nr==0) {
        $sel->remove($_);
        close($_->[0]);
      };
    };
  }
  main;
